<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<title>Square Game!</title>
		<script>
			function getRandomInt(min, max) {
				min = Math.ceil(min);
				max = Math.floor(max);
				return Math.floor(Math.random() * (max - min + 1)) + min;
			}

			/**
			 * Represents a move during a SquareGame.
			 */
			class SquareGameMove {
				/**
				 * Represents a move during a SquareGame.
				 * @param {rowIndex} The row from which to remove squares.
				 * @param {squareCount} The number of squares to remove.
				 */
				constructor(rowIndex, squareCount) {
					this.rowIndex = rowIndex;
					this.squareCount = squareCount;
				}
			}

			/**
			 * Represents a given board state of a SquareGame.
			 */
			class SquareGameBoard {
				/**
				 * Creates a new SquareGameBoard with the given row counts.
				 * @param {el} The container HTMLElement (defaults to #gameboard-container)
				 */
				constructor(rowCounts) {
					this.rowCounts = rowCounts;
				}
				addSquare(row) {
					if(this.rowCounts[row]<7){
						this.rowCounts[row]++;
					};
					drawBoard(this, "provisional");
				}
				removeSquare(row) {
					if(this.rowCounts[row]>1){this.rowCounts[row]--};
					drawBoard(this, "provisional");
				}

				/**
				 * Applies a move to a given board.
				 * @param {move} The move to apply.
				 */
				applyMove(move) {
					if (move.rowIndex >= this.rowCount || move.squareCount > this.rowCounts[move.rowIndex]) {
						throw new RangeError("Illegal move.");
					} else {
						this.rowCounts[move.rowIndex] -= move.squareCount;
					}
				}

				/**
				 * Undoes a move that was previously applied to the board and returns a new SquareGameBoard representing the board before the move.
				 * @param {move} The move to undo.
				 */
				invertMove(move) {
					if (move.rowIndex < 0 || move.rowIndex >= this.rowCount) {
						throw new RangeError("Illegal row.");
					}
					var oldState = new SquareGameBoard(this.rowCounts.map((x) => x));
					oldState.rowCounts[move.rowIndex] += move.squareCount;
					return oldState;
				}

				/**
				 * Returns the number of squares in the specified row.
				 */
				getRowLength(rowIndex) {
					if (rowIndex < 0 || rowIndex >= this.rowCount) {
						throw new RangeError("Illegal row.");
					}
					return this.rowCounts[rowIndex];
				}

				/**
				 * Draws the board state to the console.
				 */
				renderDebugBoard() {
					for (var value of this.rowCounts) {
						console.log(value);
					}
				}
				/**
				 * Returns the number of rows that this board has.
				 */
				get rowCount() {
					return this.rowCounts.length;
				}

				/**
				 * Generates a random SquareGameBoard.
				 * @param {rows} The number of rows that the board has.
				 * @param {maxPerRow} The maximum number of squares in each row that the board can have.
				 */
				static generateBoard(rows, maxPerRow) {
					return new SquareGameBoard(Array.apply(null, Array(rows)).map((x) => getRandomInt(1, maxPerRow)));
				}
			}

			/**
			 * Represents a competitor (human or computer) in a SquareGame.
			 */
			class PlayerAgent {
				constructor() {}

				/**
				 * Called by a SquareGame when it is this player's turn to move.
				 * @param {game} The SquareGame for which the player must move.
				 */
				onPlayerTurn(game) {
					console.log("It is the player's turn.");
					game.board.renderDebugBoard();
				}
			}

			/**
			 * Represents a computer player in a SquareGame.
			 */
			class ComputerAgent extends PlayerAgent {
				/**
				 * Creates a new computer player with the given timeout time.
				 * @param {timeOutTime} The time to wait before making a move. Defaults to 0.
				 */
				constructor(timeOutTime = 1) {
					super();
					this.timeOutTime = timeOutTime;
				}

				onPlayerTurn(game) {
					setTimeout(() => {
						var move = this.calculateBestMove(game.board);
						if (move == undefined) {
							game.makeMove(this, this.calculateRandomMove(game.board));
						} else {
							game.makeMove(this, move);
						}
					}, this.timeOutTime);
				}

				calculateBestMove(board) {
					var boardNumber = 0;
					for (let row = 0; row < board.rowCount; row++) {
						boardNumber ^= board.getRowLength(row);
					}
					if (boardNumber == 0) {
						return undefined;
					} else {
						for (let row = 0; row < board.rowCount; row++) {
							var len = board.getRowLength(row);
							if (len > (len ^ boardNumber)) {
								return new SquareGameMove(row, len - (len ^ boardNumber));
							}
						}
						throw new Error("Could not find a best move despite the board being magic.");
					}
				}

				calculateRandomMove(board) {
					var nonZeroRows = board.rowCounts.filter((x) => x > 0).length;
					var rowNumber = getRandomInt(1, nonZeroRows);
					var index = 0;
					while (rowNumber > 0) {
						if (board.getRowLength(index) > 0) {
							rowNumber--;
						}
						if (rowNumber > 0) {
							index++;
						}
					}
					return new SquareGameMove(index, getRandomInt(1, board.getRowLength(index)));
				}
			}

			/**
			 * Represents an instance of a Discrete Structures square game.
			 */
			class SquareGame {
				/**
				 * Creates a new SquareGame with the specified board layout between the two given players.
				 * @param {board} The beginning board state.
				 * @param {agentA} The first player.
				 * @param {agentB} The second player.
				 */
				constructor(agentA, agentB, board) {
					this.board = board;

					this.onBoardChanged = new Event("game-changed");
					this.onBoardChanged.game = this;

					this.gameComplete = new Event("game-complete");
					this.gameComplete.game = this;

					this.playerA = agentA;
					this.playerB = agentB;

					this.pastMoves = new Array();

					this.playerA.onPlayerTurn(this);
				}

				/**
				 * Makes the specified move on the board as the given player.
				 * @param {agent} The player that is making the move.
				 * @param {move} The move to make.
				 */
				makeMove(agent, move) {
					console.dir({ agent, move });
					if (agent != this.nextPlayer) {
						throw new Error("It is not the given player's turn.");
					}

					this.board.applyMove(move);
					this.pastMoves.push(move);
					setTimeout(() => {
						document.dispatchEvent(this.onBoardChanged);
						if (this.isComplete) {
							document.dispatchEvent(this.gameComplete);
						} else {
							this.nextPlayer.onPlayerTurn(this);
						}
					}, 1);
				}

				/**
				 * Returns what the state of the board was after a given number of moves.
				 * @param {turnNumber} The number of turns taken to get to the board in question.
				 */
				getBoardStateAtTurn(turnNumber) {
					if (turnNumber > this.moveCount || turnNumber < 0) {
						throw new RangeError("The turn number is out of range.");
					}

					var walkBack = this.pastMoves.length - turnNumber;
					var state = this.board;
					for (let i = 0; i < walkBack; i++) {
						state = state.invertMove(this.pastMoves[this.pastMoves.length - 1 - i]);
					}
					return state;
				}

				/**
				 * Returns the number of moves that have been made during the game.
				 */
				get moveCount() {
					return this.pastMoves.length;
				}

				/**
				 * Returns whether the game is complete.
				 */
				get isComplete() {
					for (var value of this.board.rowCounts) {
						if (value > 0) {
							return false;
						}
					}
					return true;
				}

				/**
				 * Returns the player who will make the next move.
				 */
				get nextPlayer() {
					return this.pastMoves.length % 2 == 0 ? this.playerA : this.playerB;
				}

				/**
				 * Returns the winner of this game, or throws an error if the game is still in-progress.
				 */
				get winner() {
					if (!this.isComplete) {
						throw new Error("The game is not complete.");
					}
					return this.pastMoves.length % 2 == 0 ? this.playerB : this.playerA;
				}

				static generateNewSquareGame(playerA, playerB, rowCountMin = 3, rowCountMax = 7, rowLengthMax = 6) {
					return new SquareGame(playerA, playerB, SquareGameBoard.generateBoard(getRandomInt(rowCountMin, rowCountMax), rowLengthMax));
				}
			}
		</script>
		<script></script>
		<style>
			#body {
				background-color: #5b899b;
				font-family: "Gluten", cursive;
				color: wheat;
				text-align: center;
			}
			
			button {
				background-color: tan;
				border: none;
				padding: 10px 6px;
				text-decoration: none;
				display: inline-block;
				font-size: 16px;
				border-radius: 5%;
				border: 2px solid tan;
			}
			button:hover{
				background-color:#bfa37c;
				border: 2px dashed red;
			}
			.hidden {
				display: none;
			}
			#gameboard-container {
				display: flex;
				flex-direction: column;
			}
			#selected-mode {
				border: 5px solid red;
				background-color: tan;
				padding: 10px 6px;
				text-decoration: none;
				display: inline-block;
				font-size: 16px;
				border-radius: 5%;
			}
			.computer-player {
				font-family: monospace;
			}
			.human-player {
				font-family: cursive;
			}
			#history-container {
				float: right;
				position: absolute;
				top: 63px;
				right: 0px;
				display: grid;
				width: 120px;
				outline: 1px solid white;
				padding: 4px;
			}
			.history-container-button-box {
				float: right;
				position: absolute;
				top: 10px;
				right: 0px;
				width: 120px;
				outline: 1px solid white;
				padding: 4px;
			}
			.row {
				display: flex;
				width: 100%;
				flex-direction: row;
				margin: 5px 0;
			}
			.square {
				padding: 20px 20px;
				display: block;
				background-color: whitesmoke;
				border: 1px solid black;
				margin: 5px;
			}
			.square-container {
				padding: 5px;
			}
			.chopping-block {
				border-style: dotted;
			}
			.human-player,
			.computer-player {
				background-color: #7ba5b5;
				width: 150px;
			}
			.active-player {
				outline: 2px solid green;
			}
		</style>
	</head>
	<body id="body">
		<script>
			let board;
			let agentA;
			let agentB;
			let game;
			let currentMoveDisplayed = 0;
			function drawHistory() {
				const el = document.getElementById("history-container");
				el.innerHTML = "";
				if (game != undefined) {
					for (let i = 0; i <= game.moveCount; i++) {
						let text;
						switch (i) {
							case 0:
								text = "Initial";
								break;
							case game.moveCount:
								text = "Current";
								break;
							default:
								text = "Row " + (game.pastMoves[i - 1].rowIndex + 1) + " take " + game.pastMoves[i - 1].squareCount;
						}
						const button = document.createElement("button");
						button.innerHTML = text;
						if (currentMoveDisplayed == i) {
							button.style.color = "green";
							button.style.fontWeight = "bold";
						} else {
							button.style.color = i % 2 == 0 ? "red" : "blue";
							button.style.fontWeight = "initial";
						}
						if (i == game.moveCount) {
							button.onclick = (ev) => {
								currentMoveDisplayed = i;
								drawBoard(game.getBoardStateAtTurn(i), "normal");
							};
						} else {
							button.onclick = (ev) => {
								currentMoveDisplayed = i;
								drawBoard(game.getBoardStateAtTurn(i), "historical");
							};
						}
						el.append(button);
					}
				}
			}
			const DISPLAY_SQUARES = 1;
			const DISPLAY_BINARY = 2;
			const DISPLAY_XOR = 4;
			const DISPLAY_PROVISIONAL_XOR = 8;
			const DISPLAY_DECIMAL = 16;
			/* mode is "normal", "provisional", or "historical" */
			function drawBoard(gameboard, mode = "normal", display = 31) {
				if (mode == "normal") {
					currentMoveDisplayed = game.moveCount;
					if (game.nextPlayer == agentA) {
						setFirstPlayerActive();
					} else {
						setSecondPlayerActive();
					}
				} else if (mode == "historical") {
					if (currentMoveDisplayed == undefined || currentMoveDisplayed % 2 == 0) {
						setFirstPlayerActive();
					} else {
						setSecondPlayerActive();
					}
				} else if (mode == "provisional") {
					game = undefined;
				}

				drawHistory();
				let el = document.getElementById("gameboard-container");
				const displaySquares = display % 2 === 1;
				const displayBinary = (display >>> 1) % 2 === 1;
				const displayXOR = (display >>> 2) % 2 === 1;
				const displayDecimal = (display >>> 3) % 2 === 1;
				el.innerHTML = "";
				let addable;
				let XOR = 0;
				gameboard.rowCounts.forEach((length, id) => {
					const row = document.createElement("div");
					XOR ^= length;
					row.setAttribute("data-index", id);
					row.classList.add("row");
					if (displayBinary) {
						const binRepEl = document.createElement("p");
						binRepEl.classList.add("bin-rep");
						if (length == 0) {
							binRepEl.innerHTML = "0".repeat(3);
						} else {
							binRepEl.innerHTML = "0".repeat(3 - length.toString(2).length) + length.toString(2);
						}
						row.append(binRepEl);
					}
					if (displaySquares) {
						if (length == 0) {
							let squareContainer = document.createElement("div");
							squareContainer.classList.add("square-container");
							let square = document.createElement("div");
							square.classList.add("square");
							square.classList.add("hidden");
							squareContainer.classList.add("hidden");
							squareContainer.append(square);
							row.append(squareContainer);
						} else {
							for (let i = 0; i < length; i++) {
								let squareContainer = document.createElement("div");
								squareContainer.classList.add("square-container");
								let square = document.createElement("div");
								square.classList.add("square");
								square.setAttribute("data-index", i);

								if (mode == "normal") {
									const eventhandler = (isEntering) => {
										[...square.parentElement.parentElement.children]
											.map((possibleContainer) => {
												try {
													if (!possibleContainer.children[0].classList.contains("square")) {
														throw new Error();
													}
													return possibleContainer.children[0];
												} catch (e) {
													return false;
												}
											})
											.filter((v) => v !== false)
											.reverse()
											.some((otherSquare) => {
												isEntering ? otherSquare.classList.add("chopping-block") : otherSquare.classList.remove("chopping-block");
												return otherSquare === square;
											});
									};
									squareContainer.addEventListener("mouseenter", () => eventhandler(true));
									squareContainer.addEventListener("mouseleave", () => eventhandler(false));
									square.addEventListener("click", () => {
										if (!(game.nextPlayer instanceof ComputerAgent)) {
											const rowIndex = +square.parentElement.parentElement.getAttribute("data-index");
											game.makeMove(game.nextPlayer, new SquareGameMove(rowIndex, board.getRowLength(rowIndex) - i));
										}
									});
								}
								squareContainer.append(square);
								row.append(squareContainer);
							}
							if (mode == "provisional") {
								const addButton = document.createElement("button");
								addButton.innerHTML = "+";
								addButton.addEventListener("click", () => {
									board.addSquare(id);
								});
								const removeButton = document.createElement("button");
								removeButton.innerHTML = "-";
								removeButton.addEventListener("click", () => board.removeSquare(id));
								row.append(removeButton);
								row.append(addButton);
								setFirstPlayerActive();
							}
						}
					}
					el.append(row);
				});
				if (displayXOR) {
					const XORel = document.createElement("p");
					XORel.classList.add("bin-rep", "xor");
					XORel.innerHTML = "0".repeat(3 - XOR.toString(2).length) + XOR.toString(2);
					el.append(XORel);
				}
			}

			function setPlayerActive(playerActiveId, playerInactiveId) {
				let cList = document.getElementById(playerActiveId).classList;
				if (!cList.contains("active-player")) {
					cList.add("active-player");
				}
				cList = document.getElementById(playerInactiveId).classList;
				if (cList.contains("active-player")) {
					cList.remove("active-player");
				}
			}

			function setFirstPlayerActive() {
				setPlayerActive("first-player", "second-player");
			}

			function setSecondPlayerActive() {
				setPlayerActive("second-player", "first-player");
			}
		</script>
		<h1>Square Game</h1>
		<p>Made for Northeastern University CS 1800 - Discrete Structures</p>
		<div id="mode-selector-container">
			<script>
				function setPlayer(p, isComputer) {
					const el = document.getElementById(p == 2 ? "second-player" : "first-player");
					el.innerHTML = (isComputer ? "Computer" : "Human") + " " + p;
					el.className = "";
					el.classList.add(isComputer ? "computer-player" : "human-player");
				}
				const makeElSelected = (el) => {
					document.getElementById("selected-mode").removeAttribute("id");
					el.id = "selected-mode";
					document.getElementById("gameboard-container").classList.remove("hidden");
				};
			</script>
			<button hidden style="display: none" id="selected-mode">For when no mode has been selected, this has id of selected-mode</button>
			<button class="mode-selector" id="button" onclick="makeElSelected(this);setPlayer(1,false);setPlayer(2,false);">You vs Friend</button>
			<button class="mode-selector" id="button" onclick="makeElSelected(this);setPlayer(1,false);setPlayer(2,true);">You vs Computer</button>
			<button class="mode-selector" id="button" onclick="makeElSelected(this);setPlayer(1,true);setPlayer(2,true);">Computer vs Computer</button>
		</div>
		<div id="players-container-container">
			<div id="players-container">
				<p contenteditable id="first-player" style="color:red; width: 150px"></p>
				<p contenteditable id="second-player" style="color:blue; width: 150px"></p>
			</div>
			<script>
				function swap() {
					const getInfoObject = (el) => ({
						name: el.innerHTML,
						class: el.className,
					});
					const p1el = document.getElementById("first-player");
					const p2el = document.getElementById("second-player");
					const p1 = getInfoObject(p1el);
					const p2 = getInfoObject(p2el);
					p1el.innerHTML = p2.name;
					p1el.className = p2.class;
					p2el.innerHTML = p1.name;
					p2el.className = p1.class;
				}
			</script>
			<button onclick="swap()">Swap Order</button>
		</div>
		<script>
			function setRandomRowQty() {
				document.getElementById("row-qty").value = getRandomInt(2, 9);
			}
		</script>
		<button onclick="setRandomRowQty()">Random</button>
		<input id="row-qty" min="1" type="number" />
		<script>
			setRandomRowQty();
		</script>
		<button onclick="board=SquareGameBoard.generateBoard(+document.getElementById('row-qty').value,7); drawBoard(board,'provisional');">Generate Board</button>
		<div id="gameboard-container"></div>
		<script>
			function startGame() {
				const computerDelayMS = 500;

				agentA = document.getElementById("first-player").classList.contains("computer-player") ? new ComputerAgent() : new PlayerAgent();
				agentB = document.getElementById("second-player").classList.contains("computer-player") ? new ComputerAgent() : new PlayerAgent();

				if (agentA instanceof ComputerAgent && !(agentB instanceof ComputerAgent)) {
					agentA.timeOutTime = computerDelayMS;
				} else if (agentB instanceof ComputerAgent && !(agentA instanceof ComputerAgent)) {
					agentB.timeOutTime = computerDelayMS;
				}

				game = new SquareGame(agentA, agentB, board);
				drawBoard(board);
				document.addEventListener("game-changed", () => {
					drawBoard(board);
				});
				document.addEventListener("game-complete", () => {
					const winEl = document.createElement("p");
					const winnerName = game.moveCount % 2 == 1 ? document.getElementById("first-player").innerHTML : document.getElementById("second-player").innerHTML;
					winEl.classList.add("winner-statement");
					winEl.innerHTML = winnerName + " won!";
					document.getElementById("gameboard-container").innerHTML = "";
					document.getElementById("gameboard-container").append(winEl);
					document.getElementById("reset").innerHTML = "Play Again!";
				});
			}

			function decrementMoveDisplayed() {
				if (game != undefined) {
					if (currentMoveDisplayed > 0) {
						currentMoveDisplayed--;
						drawBoard(game.getBoardStateAtTurn(currentMoveDisplayed), "historical");
					}
				}
			}

			function incrementMoveDisplayed() {
				if (game != undefined) {
					if (currentMoveDisplayed < game.moveCount) {
						currentMoveDisplayed++;
						drawBoard(game.getBoardStateAtTurn(currentMoveDisplayed), game.moveCount == currentMoveDisplayed ? "normal" : "historical");
					}
				}
			}
		</script>
		<div class="history-container-button-box">
			<button style="width: 47%" onclick="decrementMoveDisplayed()">◀</button>
			<button style="width: 47%" onclick="incrementMoveDisplayed()">▶</button>
		</div>
		<div id="history-container"></div>
		<button id="start-game" onclick="startGame()">Start Game!</button>
		<button id="reset" class="phase one" onclick="setHiddenState(0);">Play Again!</button>
	</body>
</html>
